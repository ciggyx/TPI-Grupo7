@startuml Diagrama_de_clase_Estación_Sismica 

class EventoSismico{
    - fechaInicio
    - horaInicio
    - hipocentro
    - alcance
    + new()
    + rechazarRevision()
    + bloquearRevision()
    + revisar()
    + confirmarDirecto()
    + derivar()
    + confirmarDerivado()
    + rechazarDerivado()
    + pendienteCerrar()
    + cerrar()
}

' Clase sujeta a cambios pq no se si entendí bien esto
class Magnitud{
    - nombre
    - tamaño
    - energiaLiberada Estado
    + new()
}

class MuestraSismica{
    - numMuestra
    - fechaMuestra
    - horaMuestra
    - velocidadDeOnda
    - frecuenciaOnda
    - longitud
    + new()
}
class OrigenGeneracion{
    - nombre
    - descripcion
    + new()
}

class Clasificacion{
    - nombre
    - descripción
    + new()
}

class EstacionSismica{
    - nombre
    - descripcion
    - sismografo
    + new()
}

class Sismografo{
    - nroSerie
    - fechaAdquisicion
    - modelo
    - fabricanteModelo
    + new()
}

class Fabricante{
    - nombre
    - apellido
    - modelosCreados
    - contacto
    + new()
}

class Estado{
    - nombre
    - ambito
    - descripcion
    + new()    
}

class CambioEstado{
    - nombre
    - descripcion
    + new()
}

class Alcance{
    - distancia
    + new()
}

EventoSismico "clasificacion" --> "1" Clasificacion
EventoSismico "origenGeneracion" -->"1" OrigenGeneracion
EventoSismico "alcance" --> "1" Alcance
EventoSismico "magnitud"--> "1" Magnitud
EventoSismico "estaciónSismica"--> "1" EstacionSismica
EventoSismico "muestraSismica" --> "1..*" MuestraSismica
MuestraSismica "sismografo"-->"1..*" Sismografo
Sismografo "fabricante" --> "1" Fabricante
EstacionSismica "sismografo"--> "1" Sismografo
EventoSismico "cambioEstado" -->"1" CambioEstado
CambioEstado "estado" --> "1" Estado
Sismografo "cambioEstado" --> "1" CambioEstado
@enduml

@startuml maquinaEstadoEventoSismico
hide empty description
'Casos de uso:
'23: Registrar resultado de revisión manual
'24: Registrar evento sísmico
'25: Modificar evento sísmico
'27: Anular evento sísmico
'38: Verificar eventos sísmicos auto detectados
'39: Cerrar evento sísmico
'67: Registrar resultado de revisión de un evento sismico derivado

[*]-->AutoDetectado : 24. \n new() [magnitudSismo < 4.0]
[*]-->AutoConfirmado : 24. \n new() [magnitudSismo >= 4.0]
AutoDetectado-->PendienteRevision :  25. \n revisar() \n [tiempoEspera=5min] 
PendienteRevision-->BloqueadoRevision: 25 \n bloquearRevision() [revisionSi=Si \n & tiempoEspera<5min]
PendienteRevision-->EventoSinRevision: 27. bloquearRevision() [revisionSi=No \n & tiempoEspera=5min]
AutoDetectado --> BloqueadoRevision: 25. \n revisar() \n [tiempoEspera<5min]
BloqueadoRevision-->Confirmado: 23.\n confirmarDirecto()
BloqueadoRevision-->Rechazado:  23.\n rechazarRevision()
BloqueadoRevision-->DerivadoExperto:  23.\n derivar()
DerivadoExperto-->Confirmado: 67. \n confirmarDerivado()
DerivadoExperto-->Rechazado: 67. \n rechazarDerivado()
Confirmado-->PendienteCierre: 23. \n pendienteCerrar()
AutoConfirmado-->PendienteCierre: 24.\n pendienteCerrar()
PendienteCierre --> Cerrado: 39. \n cerrar()
Cerrado --> [*]
EventoSinRevision --> [*]
Confirmado --> [*]
Rechazado --> [*]
@enduml

@startuml Parte_Dinámica_CU_23
autonumber
actor "__:AnalistaEnSismos__" as AES
create boundary "__:PantallaRegistrarResultado__" as PRR
AES --> PRR: 1. opcRegistrarResultadoManual()
PRR -> PRR: 2. abrirVentana()
create control "__:GestorRegistrarResultado__" as GRR
PRR --> GRR: 3. newRevisiónManual()
GRR -> GRR: 4. buscarEventosSísmicosAD()
loop Eventos Sísmicos Auto Detectados
else Mientras existan eventos sísmicos
    entity "__:EventoSísmico__" as ES #LightCoral
    GRR --> ES: 5. esPendienteRevisión()
    entity "__:EventoEstado__" as E
    ES --> E: 6. sosPendienteRevisión()
    GRR --> ES: 5. esAutodetectado()
    ES --> E: 6. sosAutodetectado()
    GRR -> ES: getDatos()
    ES -> ES: getFechaHoraOcurrenciaEvento()
    ES -> ES: 8. getLatitudEpicentro()
    ES -> ES: 9. getLongitudEpicentro()
    ES -> ES: 10. getLatitudHipocentro()
    ES -> ES: 11. getLongitudHipocentro()
end
GRR -> GRR: 12. ordenarEventosSísmicos()
GRR -> PRR: 13. solicitarSelecciónEventoSísmico()
AES -> PRR: 14. tomarSelecciónEventoSísmico()
PRR -> GRR: 15. tomarSelecciónEventoSísmico()
GRR -> GRR: 16. buscarEstadoBloqueado()
entity "__:Estado__" as Es #LightCoral
loop Buscar estado bloqueado en revisión
else Mientras existan estados
    GRR -> Es: sosÁmbitoEventoSísmico()
    GRR -> Es: sosBloqueadoEnRevisión()
end
GRR -> GRR : getFechaHoraActual()
GRR -> GRR : buscarEmpleadoLogueado()
entity "__Actual:Sesión__" as ASS
GRR -> ASS : getUsuarioLogueado()
entity "__Logueado:Usuario__" as US
ASS -> US: getEmpleado()
GRR -> GRR: 16. bloquearEventoSísmico()
entity "__Selecc:EventoSísmico__" as SES
GRR -> SES: bloquearEventoSísmico() 
loop Buscar último cambio estado
else Mientras existan cambios de estado
    entity "__:CambioEstado__" as CE #LightCoral
    SES -> CE: esEstadoActual() 
end
entity "__Actual:CambioEstado__" as ACE
SES -> ACE : setFechaHoraFin()
SES -> SES: crearCambioEstado()
create entity "__New:CambioEstado__" as NCE
SES --> NCE: new()
SES -> SES : setEstado()
GRR -> GRR: 20. buscarDatosSísmicos()
GRR -> SES : getDatosSísmicos()
entity "__:AlcanceSismo__" as AS
SES -> AS: 22. getNombre()
entity "__:ClasificaciónSismo__" as CS
SES -> CS: 24. getNombre()
entity "__:OrigenDeGeneración__" as OG
SES -> OG: 26. getNombre()
loop Valores alcanzados sísmo
else Mientras existan series temporales
    entity "__:SerieTemporal__" as ST
    SES --> ST: 27. getDatos()
    loop Valores muestras sísmicas
    else Mientras existan muestras sísmicas
        entity "__:MuestraSísmica__" as MS
        ST --> MS: 28. getDatos()
        loop Valores detalle muestras sísmicas
        else Mientras existan detalles muestras sísmicas
            entity "__:DetalleMuestraSísmica__" as DMS
            MS --> DMS: 29. getDatos()
            entity "__:TipoDeDato__" as TD
            DMS --> TD: 30. getDenominación()
            DMS -> TD: 31. getNombreUnidadMedida()
            DMS -> TD: 32. getValorUmbral()
            
        end
    end
end

' GRR -> GRR: 33. clasificarPorEstación()????
' GRR -> GRR: 34. llamarCUGenerarSismograma()????
' GRR -> PRR: 35. solicitarSelecciónMapa()
' AES -> PRR: 36. tomarSelecciónMapa()
' PRR -> GRR: 37. tomarSeleccionMapa()
' GRR -> PRR: 38. solicitarModificaciónDatosES()
' AES -> PRR: 39. tomarModificaciónDatosES()
' PRR -> GRR: 40. tomarModificaciónDatosES()
' GRR -> PRR: 41. solicitarAcciónSobreEvento()
' AES -> PRR: 42. tomarAcciónSobreEvento()
' PRR -> GRR: 43. tomarAcciónSobreEvento()
' GRR -> GRR: 44. validarDatos()
' GRR -> GRR: 45. obtenerFechaHoraActual()
' GRR -> GRR: 46. obtenerASLogueado()???
' GRR -> SES: 47. rechazarEvento()
' SES -> CE: 48. new()
' CE -> E: 49. new()
' GRR -> GRR: 50. finCU()
@enduml

@startuml Parte_Estática_CU_23
hide <<Entity>> circle
hide <<Boundary>> circle
hide <<Control>> circle
class PantallaRegistrarRevisión<<Boundary>>{
    - opcCancelar
    - lblFechaHoraOcurrencia
    - lblLatitudEpicentro
    - lblLongitudEpicentro
    - lblLatidudHipocentro
    - lblLongitudHipocentro
    - opcVisualizarMapa
    - inputMagnitud
    - inputAlcance
    - inputOrigenGeneración
    - opcNoModificarDatos
    - opcConfirmarEvento
    - opcRechazarEvento
    - opcSolicitarRevisiónAExperto
    + 1. opcRegistrarResultadoManual()
    + 2. abrirVentana()
    + 13. solicitarSelecciónEventoSísmico()
    + 14. tomarSelecciónEventoSísmico()
    + 17. mostrarEvSismPSel()
    + 35. solicitarSelecciónMapa()
    + 36. tomarSelecciónMapa()
    + 38. solicitarModificaciónDatosES()
    + 39. tomarModificaciónDatosES()
    + 41. solicitarAcciónSobreEvento()
    + 42. tomarAcciónSobreEvento()
}
class GestorRegistrarRevisión<<Control>>{
    - fechaHoraOcurrencia
    - latitudEpicentro
    - longitudEpicentro
    - latidudHipocentro
    - longitudHipocentro
    - eventoSísmico
    - eventoSísmicoSeleccionado
    - fechaHoraActual
    - ASLogueado
    + 3. newRevisiónManual()
    + 4. buscarEventosSísmicosAD()
    + 12. ordenarEventosSísmicos()
    + 15. tomarSelecciónEventoSísmico()
    + 16. bloquearEventoSísmico()
    + 20. buscarDatosSísmicos()
    + 33. clasificarPorEstación()
    + 34. llamarCUGenerarSismograma()
    + 37. tomarSelecciónMapa()
    + 40. tomarModificaciónDatosES()
    + 43. tomarAcciónSobreEvento()
    + 44. validarDatos()
    + 45. obtenerFechaHoraActual()
    + 46. obtenerASLogueado()
    + 50. finCU()
}
class EventoSísmico<<Entity>>{
    - estado
    - fechaHoraOcurrencia
    - latitudEpicentro
    - longitudEpicentro
    - latidudHipocentro
    - longitudHipocentro
    - cambioEstado
    - alcance
    - clasificación
    - origen
    - serieTemporal
    + 5. estaRevisado()
    + 7. getFechaHoraOcurrenciaEvento()
    + 8. getLatitudEpicentro()
    + 9. getLongitudEpicentro()
    + 10. getLatitudHipocentro()
    + 11. getLongitudHipocentro()
    + 17. bloquearEventoSísmico()
    + 21. getAlcance()
    + 23. getClasificación()
    + 25. getOrigen()
    + 47. rechazarEvento()
}
class Estado<<Entity>>{
    - nombre
    + 6. getNombre()
    + 19. new()
    + 49. new()
}
class CambioEstado<<Entity>>{
    - estado
    - fechaHoraInicio
    - ASLogueado
    + 18. new()
    + 48. new()
}
class AlcanceSismo<<Entity>>{
    - nombre
    + 22. getNombre()
}
class ClasificaciónSismo<<Entity>>{
    - nombre
    + 24. getNombre()
}
class OrigenDeGeneración<<Entity>>{
    - nombre
    + 26. getNombre()
}
class SerieTemporal<<Entity>>{
    - muestraSísmica
    + 27. getDatos()
}
class MuestraSísmica<<Entity>>{
    - detalleMuestraSísmica
    + 28. getDatos()
}
class DetalleMuestraSísmica<<Entity>>{
    - tipoDeDato
    + 29. getDatos()
}
class TipoDeDato<<Entity>>{
    - denominación
    - nombreUnidadMedida
    - valorUmbral
    + 30. getDenominación()
    + 31. getNombreUnidadMedida()
    + 32. getValorUmbral()
}

class Empleado<<Entity>>{
}

class Sesion<<Entity>>{
    -fechaHoraInicio
    -fechaHoraFin
}

class Usuario<<Entity>>{

}

GestorRegistrarRevisión ..> Sesion
Sesion -->"1" Usuario
Usuario -->"1" Empleado

PantallaRegistrarRevisión ..> GestorRegistrarRevisión

GestorRegistrarRevisión ..> PantallaRegistrarRevisión
GestorRegistrarRevisión ..> EventoSísmico
GestorRegistrarRevisión ..> Empleado

EventoSísmico --> "1" Estado
EventoSísmico --> "1..*" CambioEstado
EventoSísmico --> "1" AlcanceSismo
EventoSísmico --> "1" ClasificaciónSismo
EventoSísmico --> "1" OrigenDeGeneración
EventoSísmico --> "1..*" SerieTemporal

CambioEstado --> "1" Empleado

SerieTemporal o.. "1..*" MuestraSísmica

MuestraSísmica o.. "1..*" DetalleMuestraSísmica

DetalleMuestraSísmica --> "1" TipoDeDato

@enduml 

@startuml Parte_Dinámica_CU_23_Copy
actor "__:AnalistaEnSismos__" as AES
create boundary "__:PantallaRegistrarResultado__" as PRR
AES --> PRR: 1. opcRegistrarResultadoManual()
PRR -> PRR: 2. abrirVentana()
create control "__GestorRegistrarResultado__" as GRR
PRR --> GRR: 3. newRevisiónManual()
GRR -> GRR: 4. buscarEventosSísmicosAD()

loop Eventos Sísmicos Auto Detectados
else Mientras existan eventos sísmicos
    entity "__:EventoSísmico__" as ES #LightCoral
    GRR --> ES: 5. esAutoDetectado()
    entity "__:Estado__" as E #LightCoral

    ES -> E: 6. sosAutodetected()
    GRR -> ES: 7. esPendienteRevision()
    ' aplicamos el patron experto' 


    ES -> E: 8. esPendienteRevision()


    GRR -> ES: 9. getDatosPrincipales
    ES ->ES: 10. getFechaHora()
    ES -> ES: 11. getValorMagnitud()
    ES -> ES: 12. getLatitudEpicentro()
    ES -> ES: 13. getLongitudEpicentro()
    ES -> ES: 14. getLatitudHipocentro()
    ES -> ES: 15. getLongitudHipocentro()
end
' Va acá xq lo ha
GRR -> GRR: 16. ordenarEventosSísmicos()

GRR -> PRR: 17. mostrarEvSismPSel()

GRR -> PRR: 17. solicitarSelecciónEventoSísmico()

AES -> PRR: 18. tomarSelecciónEventoSísmico()
PRR -> GRR: 19. tomarSelecciónEventoSísmico()


GRR->GRR: 20. buscarEstado()


loop Estados p/EventoSismico
else Mientras Exista estados
GRR->E: esAmbitoEventoSísmico()
GRR->E: esBloqueadoEnRevision()
end

GRR->GRR: tomarFechaHoraActual()
GRR->GRR: buscarEmpleadoLogueado()
entity "__Actual:Sesion__" as ASS
GRR->ASS: obtenerUsuarioLogueado()
entity "__Log:Usuario__" as LGUSER 
ASS->LGUSER: getEmpleado()
'create entity "__:Empleado__" as EMP #LightCoral

create entity "__:CambioEstado__" as CE #LightCoral
GRR -> CE: *esFinal
GRR -> CE: setHoraFechaFin()
GRR -> GRR: crearCambioEstado()
' el set estado va en la clase que cambia el estado
create entity "__Selec:EventoSísimico__" as SES
GRR -> SES: algo  Poner logica LOCO 
SES --> CE: newCambioEstado()
GRR -> GRR: 21. bloquearEventoSísmico()

GRR --> SES: 22. bloquearEventoSísmico()
CE -> E: 24. new()
GRR -> GRR: 25. buscarDatosSísmicos()
GRR -> SES: 26. getAlcance()
entity "__:AlcanceSismo__" as AS
SES --> AS: 27. getNombre()
GRR -> SES: 28. getClasificación()
entity "__:ClasificaciónSismo__" as CS
SES --> CS: 29. getNombre()
GRR -> SES: 30. getOrigen()
entity "__:OrigenDeGeneración__" as OG
SES --> OG: 31. getNombre()
loop Valores alcanzados sísmo
else Mientras existan series temporales
    entity "__:SerieTemporal__" as ST
    SES --> ST: 32. getDatos()
    loop Valores muestras sísmicas
    else Mientras existan muestras sísmicas
        entity "__:MuestraSísmica__" as MS
        ST --> MS: 33. getDatos()
        loop Valores detalle muestras sísmicas
        else Mientras existan detalles muestras sísmicas
            entity "__:DetalleMuestraSísmica__" as DMS
            MS --> DMS: 34. getDatos()
            entity "__:TipoDeDato__" as TD
            DMS --> TD: 35. getDenominación()
            DMS -> TD: 36. getNombreUnidadMedida()
            DMS -> TD: 37. getValorUmbral()
            
        end
    end
    create entity "__:Sismografo__" as S
    ST -> S: *buscarSismografoMio()
    create entity "__:EstacionSismologica__" as ESM
    S -> ESM: getNombre()
end

SES -> SES: 38. clasificarPorEstación()
skinparam roundcorner 60
skinparam maxmessagesize 60
create participant "18.GenerarSismograma" as 18GS
GRR -> 18GS: 39. include (llama al caso de uso n°18)
'GRR -> GRR: 39. include (llama al caso de uso n°18)

GRR -> PRR: 40. habilitarOpcVisualizaciónMapa()
AES -> PRR: 41. tomarSelecciónMapa()
PRR -> GRR: 42. tomarSeleccionMapa()


GRR ->GRR: habilitarSolicitudModificarDatosES()
GRR -> PRR: 43. solicitarModificaciónDatosES()

AES -> PRR: 44. tomarModificaciónDatosES()
PRR -> GRR: 45. tomarModificaciónDatosES()


GRR -> PRR: 46. mostrarAcciónSobreEvento()

AES -> PRR: 47. tomarOpciónRechazoSobreEvento()
PRR -> GRR: 48. tomarOpciónRechazoSobreEvento()


GRR -> GRR: 49. validarDatos()
GRR -> GRR: 50. obtenerFechaHoraActual()

' buscar el ambito, el estado rechazado todo dentro de un fragmento, tiramos el recahzar, preguntar si es actual, preguntarHoraFechaUltima, creamos un nuevo cambio de estado y verificamos los datos (fecha, hora, empleado)

GRR -> GRR: 51. obtenerASLogueado()
GRR -> SES: 52. rechazarEvento()

SES -> CE: 53. new()
' setear el estado actual falta
' setear todos los atributos, como parametros y listo
'patrón creador diria Julian

CE -> E: 54. new()
GRR -> GRR: 55. finCU()
@enduml

@startuml Parte_dinámica_CU_37
autonumber
' Las flechas son siempre sincrónicas (con la punta rellena) 
create actor "__:ResponsableDeInspecciones__" as RI
create boundary "__:PantallaCierreOrdenInspección__" as PCOI
RI --> PCOI: opcCerrarOrdenInspección()
PCOI -> PCOI: abrirVentana()
create control "__:GestorCierreOrdenInspección__" as GCOI
PCOI --> GCOI: newCierreOrdenInspección()
GCOI -> GCOI: buscarEmpleadoLogueado()
entity "__Actual:Sesión__" as ASS
' sesión tiene: fecha hora inicio fecha hora fin
' y un puntero al usuario
GCOI -> ASS: obtenerUsuarioLogueado()
entity "__Log:Usuario__" as LU
ASS -> LU: getEmpleado()
' ¿Acá se supone que el Gestor 
' tiene el puntero del Empleado? Si, 
' ya que no es necesario tener el nombre,
' apellido del empleado, solo nos interesa
' el puntero
GCOI -> GCOI: buscarOrdenesDeInspecciónFinalizadas()
loop Ordenes de Inspección
else Mientras Existan Ordenes de Inspección
    entity "__:OrdenDeInspección__" as ODI #LightCoral
    GCOI --> ODI: esTuEmpleado()
    GCOI -> ODI: estáCompletamenteRealizada()
    '¿Está bien que sean muchos Estados? Teniendo 
    ' en cuenta que en el diagrama solo tiene 1 estado
    ' NOOOO, ESTÁ MAAAAAAL, ES UNO SOLO BURRO
    entity "__OrdInsp:Estado__" as OIE 
    ODI --> OIE: sosCompletamenteRealizada()
    GCOI -> ODI: getDatosPrincipales()
    ODI -> ODI: getNúmeroOrden()
    ODI -> ODI: getFechaFinalización()
    entity "__:EstaciónSismológica__" as ES 
    ODI --> ES: getNombreEstación()
    ODI -> ES: getSismografo()
    entity "__:Sismografo__" as S 
    ES -> S: getIdentificadorSismografo()
end
GCOI -> GCOI: ordenarPorFechaFinalización()
GCOI -> PCOI: mostrarOrdenesDeInspección()
GCOI -> PCOI: solicitarSeleccionOrdenInspección()
RI -> PCOI: tomarSelecciónOrdenInspección()
PCOI -> GCOI: tomarSelecciónOrdenInspección()
GCOI -> PCOI: solicitarIngresoObservación()
RI -> PCOI: tomarIngresoObservación()
PCOI -> GCOI: tomarIngresoObservación()
GCOI -> GCOI: buscarEstadoFueraSevicio()
entity "__:Estado__" as E #LightCoral
loop Encontrar estado Fuera Servicio
else Mientras existan Estados
    GCOI -> E: esÁmbitoSismografo()
    GCOI -> E: esFueraDeServicio()
end
GCOI -> GCOI: buscarMotivosTipo()
entity "__:MotivoTipo__" as MT
GCOI --> MT: * getDescripción()
GCOI -> PCOI: mostrarLosTiposMotivosFS()
' ¿Es necesario hacer un loop acá debido 
' a que hay varios Motivos y Comentarios? SUIIIIIIIII
loop Motivos Fuera de Servicio
else Mientras haya motivos tipo seleccionados 
    GCOI -> PCOI: solicitarSeleccionarMyC()
    RI -> PCOI: tomarMotivoFueraServicio()
    RI -> PCOI: tomarComentarioFueraServicio()
    PCOI -> GCOI: tomarSelecciónMyC()
end
GCOI -> PCOI: solicitarConfirmaciónCierreOI()
RI -> PCOI: tomarSelecciónConfirmaciónCierreOI()
PCOI -> GCOI: tomarSelecciónConfirmaciónCierreOI()
GCOI -> GCOI: validarDatosIngresadoPorUsuario()
loop Encontrar estado cerrada
else Mientras existan Estados
    GCOI -> E: esÁmbitoOrdenInspección()
    GCOI -> E: esCerrada()
end
GCOI -> GCOI: getFechaYHoraActual()
GCOI -> GCOI: cerrarOI()
entity "__Selec:OrdenDeInspección__" as SODI
GCOI -> SODI: cerrar()
SODI -> SODI: setEstado()
SODI -> SODI: setFechaHoraCierre()
entity "__:Estado__" as E2
SODI -> E2: new()
entity "__Selec:Sismografo__" as SS
GCOI --> SS: setEstadoActual()
entity "__:CambioEstado__" as CE
SS -> CE: new()
entity "__:MotivoFueraServicio__" as MFS
CE --> MFS: new()
entity "__:MotivoTipo__" as MT
MFS --> MT: new()
'kileamos el actualizarEstado()
' ¿Esto se supone que tiene que estar 
' en color?
entity "__:Estado__" as E3
SS --> E3: new()
' NO ENTIENDO NADA TANTAS PREGUNTAS SIN RESPONDER
' CREO QUE ESTOY HACIENDO TODO MAL

' LA PARTE LOCA DEL MAIL
GCOI -> GCOI: buscarMailDeLosResnponsables()
loop Mail de los responsables 
else Mientras existan empleados
    entity "__:Empleado__" as EM
    GCOI --> EM: sosResponsableDeRepación()
    entity "__:Rol__" as R
    EM --> R: getNombreRol()
    GCOI -> EM: obtenerMail()
end
GCOI -> GCOI: publicarEnMonitores()
create boundary "InterfazCCRS" as IT
GCOI -> IT: *publicar()
GCOI -> GCOI: enviarMail()
create boundary "InterfarEmail" as IM
GCOI -> IM: enviarMail()
' Si tuviera que imprimir algo tuviera una interfaz de impresora
@enduml
@startuml Parte_estática_CU_37
class Sesión
@enduml